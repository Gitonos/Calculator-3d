<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chess Game</title>
    <!-- Inline styles instead of external CDNs -->
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2d1b1b, #1a1e22);
            min-height: 100vh;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
        }
        .game-layout {
            display: flex;
            gap: 2rem;
            align-items: flex-start;
        }
        .chess-board-container {
            background: linear-gradient(135deg, #30353b, #1a1e22);
            border-radius: 1rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            flex: 1;
            display: flex;
            justify-content: center;
        }
        .control-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
            padding: 1.5rem;
            width: 300px;
            flex-shrink: 0;
        }
        .btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
            font-size: 14px;
        }
        .btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        .btn-primary {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }
        .btn-primary:hover {
            background: rgba(59, 130, 246, 0.5);
        }
        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        .status-display {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
            color: white;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        .move-item {
            color: #ccc;
            padding: 0.25rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }
        .instructions {
            font-size: 11px;
            color: #999;
            margin-top: 1rem;
            line-height: 1.4;
        }
        .instructions ul {
            margin: 0.5rem 0 0 1rem;
            padding: 0;
        }
        .instructions li {
            margin-bottom: 0.25rem;
        }
        .chess-square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s ease;
        }
        .chess-square:hover {
            opacity: 0.8;
        }
        .chess-piece {
            font-size: 36px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            user-select: none;
        }
        @media (max-width: 1024px) {
            .game-layout {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
            }
            .chess-board-container {
                order: -1;
            }
            #chess-board {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
            }
            .chess-square {
                width: 50px;
                height: 50px;
            }
            .chess-piece {
                font-size: 28px;
            }
        }
    </style>

    <!-- Simplified version without external dependencies for now -->
</head>
<body>
    <div id="root">
        <div class="container">
            <h1 class="title">Chess Game</h1>
            
            <div class="game-layout">
                <!-- Game Board -->
                <div class="chess-board-container">
                    <div id="chess-board"></div>
                </div>
                
                <!-- Control Panel -->
                <div class="control-panel">
                    <!-- Game Status -->
                    <div class="status-display">
                        <div style="font-size: 18px; margin-bottom: 8px;">Current Player</div>
                        <div id="current-player" style="font-size: 24px; font-weight: bold; text-transform: capitalize;">white</div>
                        <div id="selected-info" style="font-size: 12px; margin-top: 8px; color: #ffeb3b; display: none;"></div>
                    </div>

                    <!-- Game Controls -->
                    <div>
                        <button onclick="resetGame()" class="btn">New Game</button>
                        <button id="ai-button" onclick="toggleAI()" class="btn">AI: OFF</button>
                        <div class="btn-grid">
                            <button onclick="saveGame()" class="btn">Save</button>
                            <button onclick="loadGame()" class="btn">Load</button>
                        </div>
                    </div>

                    <!-- Move History -->
                    <div>
                        <h3 style="color: white; font-weight: 600; margin: 16px 0 8px 0; font-size: 16px;">Move History</h3>
                        <div id="move-history" class="move-history"></div>
                    </div>

                    <!-- Instructions -->
                    <div class="instructions">
                        <div style="font-weight: 600; margin-bottom: 4px;">How to Play:</div>
                        <ul>
                            <li>• Click a piece to select it</li>
                            <li>• Valid moves are highlighted in green</li>
                            <li>• Click a highlighted square to move</li>
                            <li>• Toggle AI for computer opponent</li>
                            <li>• Save/Load games to local storage</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple Chess Game Implementation without external dependencies
        
        // Chess game state
        let gameState = {
            board: [],
            currentPlayer: 'white',
            selectedSquare: null,
            validMoves: [],
            moveHistory: [],
            aiMode: false
        };

        // Chess Logic Module
        const ChessLogic = {
            createInitialBoard: () => {
                const board = Array(8).fill(null).map(() => Array(8).fill(null));
                
                // Place black pieces
                const backRowPieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                backRowPieces.forEach((piece, i) => {
                    board[0][i] = { type: piece, color: 'black' };
                });
                for (let i = 0; i < 8; i++) {
                    board[1][i] = { type: 'pawn', color: 'black' };
                }
                
                // Place white pieces
                for (let i = 0; i < 8; i++) {
                    board[6][i] = { type: 'pawn', color: 'white' };
                }
                backRowPieces.forEach((piece, i) => {
                    board[7][i] = { type: piece, color: 'white' };
                });
                
                return board;
            },

            isValidMove: (board, fromRow, fromCol, toRow, toCol, currentPlayer) => {
                if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||
                    toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
                
                const piece = board[fromRow][fromCol];
                if (!piece || piece.color !== currentPlayer) return false;
                
                const targetPiece = board[toRow][toCol];
                if (targetPiece && targetPiece.color === piece.color) return false;
                
                return ChessLogic.validatePieceMove(board, piece, fromRow, fromCol, toRow, toCol);
            },

            validatePieceMove: (board, piece, fromRow, fromCol, toRow, toCol) => {
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                const absRowDiff = Math.abs(rowDiff);
                const absColDiff = Math.abs(colDiff);

                switch (piece.type) {
                    case 'pawn':
                        const direction = piece.color === 'white' ? -1 : 1;
                        const startRow = piece.color === 'white' ? 6 : 1;
                        
                        if (colDiff === 0) {
                            if (rowDiff === direction && !board[toRow][toCol]) return true;
                            if (fromRow === startRow && rowDiff === 2 * direction && !board[toRow][toCol]) return true;
                        }
                        if (absColDiff === 1 && rowDiff === direction && board[toRow][toCol]) return true;
                        break;
                        
                    case 'rook':
                        if (rowDiff === 0 || colDiff === 0) {
                            return ChessLogic.isPathClear(board, fromRow, fromCol, toRow, toCol);
                        }
                        break;
                        
                    case 'knight':
                        return (absRowDiff === 2 && absColDiff === 1) || (absRowDiff === 1 && absColDiff === 2);
                        
                    case 'bishop':
                        if (absRowDiff === absColDiff) {
                            return ChessLogic.isPathClear(board, fromRow, fromCol, toRow, toCol);
                        }
                        break;
                        
                    case 'queen':
                        if (rowDiff === 0 || colDiff === 0 || absRowDiff === absColDiff) {
                            return ChessLogic.isPathClear(board, fromRow, fromCol, toRow, toCol);
                        }
                        break;
                        
                    case 'king':
                        return absRowDiff <= 1 && absColDiff <= 1;
                }
                return false;
            },

            isPathClear: (board, fromRow, fromCol, toRow, toCol) => {
                const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
                const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
                
                let currentRow = fromRow + rowStep;
                let currentCol = fromCol + colStep;
                
                while (currentRow !== toRow || currentCol !== toCol) {
                    if (board[currentRow][currentCol]) return false;
                    currentRow += rowStep;
                    currentCol += colStep;
                }
                return true;
            },

            makeMove: (board, fromRow, fromCol, toRow, toCol) => {
                const newBoard = board.map(row => [...row]);
                const piece = newBoard[fromRow][fromCol];
                
                if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                    piece.type = 'queen';
                }
                
                newBoard[toRow][toCol] = piece;
                newBoard[fromRow][fromCol] = null;
                return newBoard;
            }
        };

        // Initialize the game
        function initGame() {
            gameState.board = ChessLogic.createInitialBoard();
            gameState.currentPlayer = 'white';
            gameState.selectedSquare = null;
            gameState.validMoves = [];
            gameState.moveHistory = [];
            renderBoard();
            updateUI();
        }

        // Render the chess board as a 2D grid
        function renderBoard() {
            const boardElement = document.getElementById('chess-board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'chess-square';
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    const isLight = (row + col) % 2 === 0;
                    square.style.backgroundColor = isLight ? '#f0d9b5' : '#b58863';
                    
                    // Highlight selected square
                    if (gameState.selectedSquare && 
                        gameState.selectedSquare.row === row && 
                        gameState.selectedSquare.col === col) {
                        square.style.backgroundColor = '#7b68ee';
                    }
                    
                    // Highlight valid moves
                    if (gameState.validMoves.some(move => move.row === row && move.col === col)) {
                        square.style.backgroundColor = '#90ee90';
                    }
                    
                    // Add piece if present
                    const piece = gameState.board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'chess-piece';
                        pieceElement.textContent = getPieceSymbol(piece);
                        pieceElement.style.color = piece.color === 'white' ? '#fff' : '#000';
                        square.appendChild(pieceElement);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        function getPieceSymbol(piece) {
            const symbols = {
                'king': '♔',
                'queen': '♕',
                'rook': '♖',
                'bishop': '♗',
                'knight': '♘',
                'pawn': '♙'
            };
            return symbols[piece.type] || '?';
        }

        function handleSquareClick(row, col) {
            if (gameState.selectedSquare) {
                if (ChessLogic.isValidMove(gameState.board, 
                    gameState.selectedSquare.row, gameState.selectedSquare.col, 
                    row, col, gameState.currentPlayer)) {
                    
                    const piece = gameState.board[gameState.selectedSquare.row][gameState.selectedSquare.col];
                    const targetPiece = gameState.board[row][col];
                    const moveNotation = `${piece.type} ${String.fromCharCode(97 + gameState.selectedSquare.col)}${8 - gameState.selectedSquare.row} → ${String.fromCharCode(97 + col)}${8 - row}${targetPiece ? ' (captures)' : ''}`;
                    
                    gameState.board = ChessLogic.makeMove(gameState.board, 
                        gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    gameState.moveHistory.push(moveNotation);
                    gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
                    gameState.selectedSquare = null;
                    gameState.validMoves = [];
                    
                    playMoveSound();
                    renderBoard();
                    updateUI();
                    
                    if (gameState.aiMode && gameState.currentPlayer === 'black') {
                        setTimeout(makeAIMove, 1000);
                    }
                } else {
                    selectPiece(row, col);
                }
            } else {
                selectPiece(row, col);
            }
        }

        function selectPiece(row, col) {
            const piece = gameState.board[row][col];
            if (piece && piece.color === gameState.currentPlayer) {
                gameState.selectedSquare = { row, col };
                
                const moves = [];
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (ChessLogic.isValidMove(gameState.board, row, col, r, c, gameState.currentPlayer)) {
                            moves.push({ row: r, col: c });
                        }
                    }
                }
                gameState.validMoves = moves;
            } else {
                gameState.selectedSquare = null;
                gameState.validMoves = [];
            }
            renderBoard();
            updateUI();
        }

        function makeAIMove() {
            const allMoves = [];
            
            for (let fromRow = 0; fromRow < 8; fromRow++) {
                for (let fromCol = 0; fromCol < 8; fromCol++) {
                    const piece = gameState.board[fromRow][fromCol];
                    if (piece && piece.color === 'black') {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (ChessLogic.isValidMove(gameState.board, fromRow, fromCol, toRow, toCol, 'black')) {
                                    allMoves.push({ fromRow, fromCol, toRow, toCol, piece });
                                }
                            }
                        }
                    }
                }
            }
            
            if (allMoves.length > 0) {
                const randomMove = allMoves[Math.floor(Math.random() * allMoves.length)];
                const targetPiece = gameState.board[randomMove.toRow][randomMove.toCol];
                const moveNotation = `AI: ${randomMove.piece.type} ${String.fromCharCode(97 + randomMove.fromCol)}${8 - randomMove.fromRow} → ${String.fromCharCode(97 + randomMove.toCol)}${8 - randomMove.toRow}${targetPiece ? ' (captures)' : ''}`;
                
                gameState.board = ChessLogic.makeMove(gameState.board, randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);
                gameState.moveHistory.push(moveNotation);
                gameState.currentPlayer = 'white';
                playMoveSound();
                renderBoard();
                updateUI();
            }
        }

        function playMoveSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function updateUI() {
            document.getElementById('current-player').textContent = gameState.currentPlayer;
            document.getElementById('current-player').style.color = gameState.currentPlayer === 'white' ? '#fff' : '#666';
            
            const selectedInfo = document.getElementById('selected-info');
            if (gameState.selectedSquare) {
                selectedInfo.textContent = `Selected: ${String.fromCharCode(97 + gameState.selectedSquare.col)}${8 - gameState.selectedSquare.row}`;
                selectedInfo.style.display = 'block';
            } else {
                selectedInfo.style.display = 'none';
            }
            
            const moveHistoryElement = document.getElementById('move-history');
            if (gameState.moveHistory.length === 0) {
                moveHistoryElement.innerHTML = '<div style="color: #666; font-size: 12px;">No moves yet</div>';
            } else {
                moveHistoryElement.innerHTML = gameState.moveHistory.map((move, index) => 
                    `<div class="move-item">${index + 1}. ${move}</div>`
                ).join('');
            }
            
            const aiButton = document.getElementById('ai-button');
            aiButton.className = gameState.aiMode ? 'btn btn-primary' : 'btn';
            aiButton.textContent = gameState.aiMode ? 'AI: ON' : 'AI: OFF';
        }

        function resetGame() {
            initGame();
        }

        function toggleAI() {
            gameState.aiMode = !gameState.aiMode;
            updateUI();
            if (gameState.aiMode && gameState.currentPlayer === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        function saveGame() {
            const gameData = {
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                moveHistory: gameState.moveHistory,
                timestamp: new Date().toISOString()
            };
            localStorage.setItem('chessGame', JSON.stringify(gameData));
            alert('Game saved!');
        }

        function loadGame() {
            try {
                const savedGame = localStorage.getItem('chessGame');
                if (savedGame) {
                    const gameData = JSON.parse(savedGame);
                    gameState.board = gameData.board;
                    gameState.currentPlayer = gameData.currentPlayer;
                    gameState.moveHistory = gameData.moveHistory || [];
                    gameState.selectedSquare = null;
                    gameState.validMoves = [];
                    renderBoard();
                    updateUI();
                    alert('Game loaded!');
                } else {
                    alert('No saved game found!');
                }
            } catch (e) {
                alert('Error loading game!');
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>